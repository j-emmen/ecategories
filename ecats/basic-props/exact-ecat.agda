
-- disable the K axiom:

{-# OPTIONS --without-K #-}

-- Agda version 2.5.4.1

module ecats.basic-props.exact-ecat where

open import ecats.basic-defs.ecat-def&not
open import ecats.basic-defs.all-arrows
open import ecats.finite-limits.all
open import ecats.basic-defs.regular-ecat
open import ecats.basic-defs.exact-ecat
open import ecats.basic-props.epi&mono
open import ecats.basic-props.image-fact
open import ecats.basic-props.regular-ecat



-- Some properties of exact categories

module exact-cat-props-only {ùîº : ecategory} (isex : is-exact ùîº) where
  open ecategory ùîº
  open arrows-defs ùîº
  open epis&monos-props ùîº
  open image-fact-props ùîº
  open binary-products ùîº
  open pullback-squares ùîº
  open pullback-props ùîº
  private
    module exùîº where
      open is-exact isex public
      open has-pullbacks haspb using (pb-of) public
      open has-equalisers haseql using (eql-of) public
      open has-bin-products hasprd using (prd-of) public
      open has-pb‚Üíhas-kerpair haspb public
      open epis&monos-pullbacks haspb public
    module Q {A : Obj} (eqr : eqrel-over A) = coeq-of (exùîº.eqr-has-coeq eqr)
    module sp/ = span/
    module sp = span
    module sq/ = square/cosp
    module sq = comm-square
    module pbof = pullback-of
    module pbsq = pb-square
    module √óof = product-of
    module prd = bin-product
    module eqr/ = eqrel-over
    module ker {A B : Obj} (f : || Hom A B ||) = pullback-of-not (exùîº.pb-of f f)


  -- Any coequaliser diagram of an equivalence relation is an exact diagram
  
  coeq-of-eqrel-is-eff : {A Q : Obj} {q : || Hom A Q ||} (eqr : eqrel-over A)
                ‚Üí is-coeq (eqr/.r‚ÇÅ eqr) (eqr/.r‚ÇÇ eqr) q
                  ‚Üí is-exact-seq (eqr/.r‚ÇÅ eqr) (eqr/.r‚ÇÇ eqr) q
  coeq-of-eqrel-is-eff eqr coeq = record
    { iscoeq = coeq
    ; iskerpair = kerpair-is-kerpair-of-coeq (record { iskpof = record
                { ispb = kerpair-is-kerpair-of-coeq (exùîº.eqr-is-eff eqr) coeq } })
                                             coeq
    }
    where module eqrQ = coeq-of (exùîº.eqr-has-coeq eqr)
    

  -- The chosen quotients of equivalence relations are effective.
  
  ex-seq : {A : Obj} (eqr : eqrel-over A)
                ‚Üí is-exact-seq (eqr/.r‚ÇÅ eqr) (eqr/.r‚ÇÇ eqr) (Q.ar eqr)
  ex-seq eqr = coeq-of-eqrel-is-eff eqr (Q.iscoeq eqr)



  module √ó/‚Çê-of-repis-is-epi {I A B A' B' : Obj}
                             {a : || Hom A I ||} {b : || Hom B I ||} {a' : || Hom A' I ||} {b' : || Hom B' I ||}
                             (pbof : pullback-of a b) (pbof' : pullback-of a' b')
                             {qa : || Hom A A' ||} {qb : || Hom B B' ||} (a-tr : a' ‚àò qa ~ a) (b-tr : b' ‚àò qb ~ b)
                             (qa-is-repi : is-regular-epi qa) (qb-is-repi : is-regular-epi qb)
                             where
    private
      a√ó/b = pbof
      a'√ó/b' = pbof'
      a√ó/b' : pullback-of a b'
      a√ó/b' = exùîº.pb-of a b'
      module qa = is-regular-epi qa-is-repi
      module qb = is-regular-epi qb-is-repi
      module a√ó/b = pullback-of-not a√ó/b
      module a'√ó/b' = pullback-of-not a'√ó/b'
      module a√ó/b' =  pullback-of-not a√ó/b'
      module √ó/ar  {I A‚ÇÅ B‚ÇÅ : Obj} {a‚ÇÅ : || Hom A‚ÇÅ I ||} {b‚ÇÅ : || Hom B‚ÇÅ I ||}
                   {A‚ÇÇ B‚ÇÇ : Obj} {a‚ÇÇ : || Hom A‚ÇÇ I ||} {b‚ÇÇ : || Hom B‚ÇÇ I ||}
                   (pbsq‚ÇÅ : pullback-of a‚ÇÅ b‚ÇÅ) (pbsq‚ÇÇ : pullback-of a‚ÇÇ b‚ÇÇ)
                   where
        open √ó/‚Çêdef pbsq‚ÇÅ pbsq‚ÇÇ public
        open √ó/‚Çênot-only pbsq‚ÇÅ pbsq‚ÇÇ public
    open √ó/‚Çê-of-pbstb-Prop-is-Prop-aux regular-epi-is-ext
                                       exùîº.repi-pbof-stable
                                       pbof'
                                       pbof
                                       a-tr
                                       b-tr
                                       a√ó/b'
                                       qa-is-repi
                                       qb-is-repi
    open √ó/‚Çê-of-pbstb-Prop-is-Prop-aux2 epi-is-congr pbof' pbof a-tr b-tr a√ó/b' qa.uniq qb.uniq
    private
      module fst = is-regular-epi fstProp
      module snd = is-regular-epi sndProp
    √ó/ar-is-epic : {h : || Hom a√ó/b.ul a'√ó/b'.ul ||}
                           ‚Üí a'√ó/b'.œÄ/‚ÇÅ ‚àò h ~ qa ‚àò a√ó/b.œÄ/‚ÇÅ ‚Üí a'√ó/b'.œÄ/‚ÇÇ ‚àò h ~ qb ‚àò a√ó/b.œÄ/‚ÇÇ ‚Üí is-epic h
    √ó/ar-is-epic pf1 pf2 = √ó/arProp-cond pf1 pf2 fst.uniq snd.uniq
    √ó/ar-pf = √ó/‚Çêcanpf a-tr b-tr
             where open √ó/‚Çêdef a'√ó/b' a√ó/b using (√ó/‚Çêcanpf)
    √ó/ar-can : || Hom a√ó/b.ul a'√ó/b'.ul ||
    √ó/ar-can = qa √ó/‚Çê qb [ a-tr , b-tr ]
          where open √ó/‚Çêdef a'√ó/b' a√ó/b using (_√ó/‚Çê_[_,_])
    √ó/ar-can-epic : is-epic √ó/ar-can
    √ó/ar-can-epic = √ó/ar-is-epic (a'√ó/b'.√ó/tr‚ÇÅ √ó/ar-pf) (a'√ó/b'.√ó/tr‚ÇÇ √ó/ar-pf)
  -- end √ó/‚Çê-of-repis-is-epi



  module exact-has-pbstable-image-fact {A B : Obj} (f : || Hom A B ||) where
    open has-pb‚Üíker-are-eqr exùîº.haspb
    open has-pb‚Üíhas-kerpair exùîº.haspb
    private
      module f√ó/f = is-kernel-pair (œÄ/iskp f)
      module kerf = eqrel-over (œÄ/kp-eqr/ f)    
    imgObf = Q.Ob (œÄ/kp-eqr/ f)
    imgCf : || Hom A imgObf ||
    imgCf = Q.ar (œÄ/kp-eqr/ f)    
    imgCf-is-repi : is-regular-epi imgCf
    imgCf-is-repi = record { rel-obj = kerf.relOb
                           ; rel‚ÇÅ = kerf.r‚ÇÅ
                           ; rel‚ÇÇ = kerf.r‚ÇÇ
                           ; coeq = iscoeq
                           }
                           where open is-exact-seq (ex-seq (œÄ/kp-eqr/ f))
                                 open is-coeq iscoeq    
    imgMf : || Hom imgObf B ||
    imgMf = univ f f√ó/f.√ó/sqpf
          where open is-exact-seq (ex-seq (œÄ/kp-eqr/ f))    
    imgTrf : imgMf ‚àò imgCf ~ f
    imgTrf = univ-eq f√ó/f.√ó/sqpf
           where open is-exact-seq (ex-seq (œÄ/kp-eqr/ f))
    imgMf-is-monic : is-monic imgMf
    imgMf-is-monic = œÄ/‚ÇÅ~œÄ/‚ÇÇ‚Üímono (exùîº.pb-of imgMf imgMf) eqœÄ/
                   where module exf = is-exact-seq (ex-seq (œÄ/kp-eqr/ f))
                         module kerMf = pullback-of-not (exùîº.pb-of imgMf imgMf)
                         open √ó/‚Çê-of-repis-is-epi f√ó/f.√ó/of (exùîº.pb-of imgMf imgMf)
                                                  imgTrf imgTrf imgCf-is-repi imgCf-is-repi
                                                  using (√ó/ar-can-epic)
                                                  renaming (√ó/ar-pf to qf√óqf-pf)
                         module qf√óqf = is-epic √ó/ar-can-epic
                         open ecategory-aux-only ùîº
                         eqœÄ/ : kerMf.œÄ/‚ÇÅ ~ kerMf.œÄ/‚ÇÇ
                         eqœÄ/ = qf√óqf.epi-pf (kerMf.√ó/tr‚ÇÅ qf√óqf-pf ‚äô exf.eq ‚äô kerMf.√ó/tr‚ÇÇ qf√óqf-pf À¢)

    imgf-is-imgfact : is-img-fact imgTrf
    imgf-is-imgfact = repi-mono-is-img-fact imgTrf  imgCf-is-repi imgMf-is-monic

    imgf-data : img-fact-of f
    imgf-data = record
      { Ob = imgObf
      ; M = imgMf
      ; C = imgCf
      ; isimg = imgf-is-imgfact
      }

    imgf-is-pbstable : {C : Obj} {g : || Hom C B ||} (g√ó/f : pullback-of g f) (g√ó/mf : pullback-of g imgMf)
                       {pbQ : || Hom (pbof.ul g√ó/f) (pbof.ul g√ó/mf) ||} (pbtr : pbof.œÄ/‚ÇÅ g√ó/mf ‚àò pbQ ~ pbof.œÄ/‚ÇÅ g√ó/f)
                         ‚Üí img-fact-is-pb-stable imgf-data g√ó/f g√ó/mf pbtr
    imgf-is-pbstable {g = g} g√ó/f g√ó/mf {pbQ} pbtr = record
      { img-pb-stable = repi-mono-is-img-fact pbtr pbQ-is-repi g*imgMf-is-monic
      }
      where module g√ó/f = pullback-of-not g√ó/f
            module g√ó/mf = pullback-of-not g√ó/mf
            module Mf = is-monic imgMf-is-monic
            open ecategory-aux-only ùîº
            pbQpf‚ÇÇ = ~proof imgMf ‚àò g√ó/mf.œÄ/‚ÇÇ ‚àò pbQ        ~[ ass ‚äô ‚àòe r (g√ó/mf.√ó/sqpf À¢) ‚äô assÀ¢ ] /
                            g ‚àò  g√ó/mf.œÄ/‚ÇÅ ‚àò pbQ           ~[ ‚àòe pbtr r ] /
                            g ‚àò pbof.œÄ/‚ÇÅ g√ó/f              ~[ g√ó/f.√ó/sqpf ‚äô ‚àòe r (imgTrf À¢) ‚äô assÀ¢ ]‚àé
                            imgMf ‚àò imgCf ‚àò g√ó/f.œÄ/‚ÇÇ ‚àé
            pbQ-is-repi : is-regular-epi pbQ
            pbQ-is-repi = pres-rl (mkpb-sq (upper-is-pbsq imgTrf pbtr (Mf.mono-pf pbQpf‚ÇÇ)))
                                  imgCf-is-repi
                        where open is-pbsq-stable exùîº.repi-pbsq-stable
                              open lower-and-outer-so-upper g√ó/mf g√ó/f
            g*imgMf-is-monic : is-monic g√ó/mf.œÄ/‚ÇÅ
            g*imgMf-is-monic = mono-pb-stable g√ó/mf imgMf-is-monic

  -- end exact-has-pbstable-image-fact
  

  -----------------------------------------------------
  -- Exact cat has pullback stable image factorisation
  -----------------------------------------------------

  exact-has-pbstb-img-fact : has-pb-stable-img-fact ùîº
  exact-has-pbstb-img-fact = record
    { imgfact = record { img-of = imgf-data }
    ; pb-stb = Œª pbsq-g*f pbsq-g*mf pbtr ‚Üí imgf-is-pbstable _ pbsq-g*f pbsq-g*mf pbtr
    }
    where open exact-has-pbstable-image-fact

  -- Hence exact categories are regular...

  exact-is-regular//has-fl : is-regular//has-finlim exùîº.hasfl
  exact-is-regular//has-fl = record
    { pb-stb-imgfact = exact-has-pbstb-img-fact
    }
    where open exact-has-pbstable-image-fact
  
  exact-is-regular : is-regular ùîº
  exact-is-regular = record
    { hasfl = exùîº.hasfl
    ; isreg/fl = exact-is-regular//has-fl
    }
      
  -- ... and enjoys the same properties.

  private
    module rùîº = is-regular//has-finlim exact-is-regular//has-fl
  open regular-cat-props exact-is-regular --public


  -- Exact cats have quotients of pseudo equivalence relations

  module exact-has-quot-peq-rel (peqR : Peq) where
    open Peq&prods exùîº.hasprd
    open ecategory-aux-only ùîº
    private
      module R = Peq-aux peqR
    imgR : img-fact-of R.%01
    imgR = rùîº.img-of R.%01
    private
      Lo√óLo : product-of R.Lo R.Lo
      Lo√óLo = exùîº.prd-of R.Lo R.Lo
      module Lo√óLo = product-of-not Lo√óLo
      module imgR = img-fact-of imgR
      imgCR-is-repi : is-regular-epi imgR.C
      imgCR-is-repi = imgC-is-repi R.%01
      module CR = is-regular-epi imgCR-is-repi
    r‚ÇÅ r‚ÇÇ : || Hom imgR.Ob R.Lo ||
    r‚ÇÅ = Lo√óLo.œÄ‚ÇÅ ‚àò imgR.M
    r‚ÇÇ = Lo√óLo.œÄ‚ÇÇ ‚àò imgR.M
    r-is-jm/ : is-jointly-monic/ (mkspan/ r‚ÇÅ r‚ÇÇ)
    r-is-jm/ = <>monic‚Üíisjm/ Lo√óLo r r imgR.M-is-monic
    tr‚ÇÅ = ~proof r‚ÇÅ ‚àò imgR.C    ~[ assÀ¢ ‚äô ‚àòe imgR.tr r  ] /
                     Lo√óLo.œÄ‚ÇÅ ‚àò R.%01    ~[ Lo√óLo.√ótr‚ÇÅ ]‚àé
                     R.%0 ‚àé
    tr‚ÇÇ = ~proof r‚ÇÇ ‚àò imgR.C    ~[ assÀ¢ ‚äô ‚àòe imgR.tr r  ] /
                     Lo√óLo.œÄ‚ÇÇ ‚àò R.%01    ~[ Lo√óLo.√ótr‚ÇÇ ]‚àé
                     R.%1 ‚àé
    iseqr : is-eq-rel r‚ÇÅ r‚ÇÇ
    iseqr = record
      { isjm/ = r-is-jm/
      ; isœÅ = record
            { œÅ = imgR.C ‚àò R.œÅ
            ; œÅ-ax‚ÇÄ = ass ‚äô ‚àòe r tr‚ÇÅ ‚äô R.œÅ-ax‚ÇÄ
            ; œÅ-ax‚ÇÅ = ass ‚äô ‚àòe r tr‚ÇÇ ‚äô R.œÅ-ax‚ÇÅ
            }
      ; isœÉ = record
            { œÉ = œÉrel
            ; œÉ-ax‚ÇÄ = ‚àòe r (Lo√óLo.√ótr‚ÇÇ {f = r‚ÇÇ} À¢) ‚äô assÀ¢ ‚äô ‚àòe (imgR.univ-tr œÉrel-monic œÉrel-comm) r
            ; œÉ-ax‚ÇÅ = ‚àòe r (Lo√óLo.√ótr‚ÇÅ {g = r‚ÇÅ} À¢) ‚äô assÀ¢ ‚äô ‚àòe (imgR.univ-tr œÉrel-monic œÉrel-comm) r
            }
      ; œÑpb = exùîº.pb-of r‚ÇÇ r‚ÇÅ
      ; isœÑ = record
            { œÑ = œÑrel
            ; œÑ-ax‚ÇÄ = œÑrel-ax‚ÇÄ
            ; œÑ-ax‚ÇÅ = œÑrel-ax‚ÇÅ
            }
      }
      where open Lo√óLo
            œÉrel-monic : is-monic Lo√óLo.< r‚ÇÇ , r‚ÇÅ >
            œÉrel-monic = isjm/‚Üí<>monic (jointly-monic-sym r-is-jm/) Lo√óLo
            œÉrel-comm = ~proof < r‚ÇÇ , r‚ÇÅ > ‚àò imgR.C ‚àò R.œÉ        ~[ ‚àòe r (Lo√óLo.<>ar~<>À¢ r r) ‚äô assÀ¢ ] /
                               < œÄ‚ÇÇ , œÄ‚ÇÅ > ‚àò imgR.M ‚àò imgR.C ‚àò R.œÉ  ~[ ‚àòe (ass ‚äô ‚àòe r imgR.tr ‚äô R.œÉ-ax) r ] /
                               < œÄ‚ÇÇ , œÄ‚ÇÅ > ‚àò < R.%1 , R.%0 >     ~[ Lo√óLo.<>ar~<> √ótr‚ÇÇ √ótr‚ÇÅ ]‚àé
                               R.%01 ‚àé
            œÉrel = imgR.univ œÉrel-monic œÉrel-comm

            open wpullback-squares ùîº
            module RœÑpb = pullback-of-not (exùîº.pb-of R.%1 R.%0)
            module RœÑwpb = wpullback-of-not R.œÑwpb
            module rœÑpb = pullback-of-not (exùîº.pb-of r‚ÇÇ r‚ÇÅ)
            module CR√óCR where
              open √ó/‚Çê-of-repis-is-repi (exùîº.pb-of r‚ÇÇ r‚ÇÅ) (exùîº.pb-of R.%1 R.%0)
                                        tr‚ÇÇ tr‚ÇÅ
                                        imgCR-is-repi imgCR-is-repi
                                        public
              open √ó/‚Çêdef (exùîº.pb-of r‚ÇÇ r‚ÇÅ) (exùîº.pb-of R.%1 R.%0) --public
              √ó/arcan-pf = √ó/‚Çêcanpf tr‚ÇÇ tr‚ÇÅ
              open is-regular-epi √ó/arcanProp public
            CR√óCR : || Hom RœÑpb.ul rœÑpb.ul ||
            CR√óCR = CR√óCR.√ó/arcan
            medœÑ : || Hom RœÑpb.ul RœÑwpb.ul ||
            medœÑ = RœÑwpb.w‚ü® RœÑpb.œÄ/‚ÇÅ , RœÑpb.œÄ/‚ÇÇ ‚ü©[ RœÑpb.√ó/sqpf ]
            medœÑ‚ÇÄ = R.%0 ‚àò R.œÑ ‚àò  medœÑ ~[ ass ‚äô ‚àòe r R.œÑ-ax‚ÇÄ ‚äô assÀ¢ ‚äô ‚àòe (RœÑwpb.w√ó/tr‚ÇÅ RœÑpb.√ó/sqpf) r
                    ] R.%0 ‚àò RœÑpb.œÄ/‚ÇÅ
            medœÑ‚ÇÅ = R.%1 ‚àò R.œÑ ‚àò  medœÑ ~[ ass ‚äô ‚àòe r R.œÑ-ax‚ÇÅ ‚äô assÀ¢ ‚äô ‚àòe (RœÑwpb.w√ó/tr‚ÇÇ RœÑpb.√ó/sqpf) r
                    ] R.%1 ‚àò RœÑpb.œÄ/‚ÇÇ
            medœÑ‚ÇÄ‚ÇÅ = R.%01 ‚àò R.œÑ ‚àò  medœÑ ~[ Lo√óLo.<>ar~<> medœÑ‚ÇÄ medœÑ‚ÇÅ ]
                     < R.%0 ‚àò RœÑpb.œÄ/‚ÇÅ , R.%1 ‚àò RœÑpb.œÄ/‚ÇÇ >

            œÑrel-aux‚ÇÅ = ~proof (r‚ÇÅ ‚àò rœÑpb.œÄ/‚ÇÅ) ‚àò CR√óCR     ~[ assÀ¢ ‚äô ‚àòe (rœÑpb.√ó/tr‚ÇÅ CR√óCR.√ó/arcan-pf) r ] /
                               r‚ÇÅ ‚àò imgR.C ‚àò RœÑpb.œÄ/‚ÇÅ      ~[ ass ‚äô ‚àòe r tr‚ÇÅ ]‚àé
                               R.%0 ‚àò RœÑpb.œÄ/‚ÇÅ ‚àé
            œÑrel-aux‚ÇÇ = ~proof (r‚ÇÇ ‚àò rœÑpb.œÄ/‚ÇÇ) ‚àò CR√óCR     ~[ assÀ¢ ‚äô ‚àòe (rœÑpb.√ó/tr‚ÇÇ CR√óCR.√ó/arcan-pf) r ] /
                               r‚ÇÇ ‚àò imgR.C ‚àò RœÑpb.œÄ/‚ÇÇ      ~[ ass ‚äô ‚àòe r tr‚ÇÇ ]‚àé
                               R.%1 ‚àò RœÑpb.œÄ/‚ÇÇ ‚àé
            œÑrel-pf = imgR.Mpf (~proof
              imgR.M ‚àò (imgR.C ‚àò R.œÑ ‚àò  medœÑ) ‚àò CR√óCR.rel‚ÇÅ            ~[ ass ‚äô ‚àòe r (ass ‚äô ‚àòe r imgR.tr) ] /
              (R.%01 ‚àò R.œÑ ‚àò  medœÑ) ‚àò CR√óCR.rel‚ÇÅ                     ~[ ‚àòe r medœÑ‚ÇÄ‚ÇÅ ] /
              < R.%0 ‚àò RœÑpb.œÄ/‚ÇÅ , R.%1 ‚àò RœÑpb.œÄ/‚ÇÇ > ‚àò CR√óCR.rel‚ÇÅ     ~[ ‚àòe r (Lo√óLo.<>ar~<>À¢ œÑrel-aux‚ÇÅ œÑrel-aux‚ÇÇ) ‚äô assÀ¢ ] /
              < r‚ÇÅ ‚àò rœÑpb.œÄ/‚ÇÅ , r‚ÇÇ ‚àò rœÑpb.œÄ/‚ÇÇ > ‚àò CR√óCR ‚àò CR√óCR.rel‚ÇÅ  ~[ ‚àòe CR√óCR.eq r ] /
              < r‚ÇÅ ‚àò rœÑpb.œÄ/‚ÇÅ , r‚ÇÇ ‚àò rœÑpb.œÄ/‚ÇÇ > ‚àò CR√óCR ‚àò CR√óCR.rel‚ÇÇ  ~[ ass ‚äô ‚àòe r (Lo√óLo.<>ar~<> œÑrel-aux‚ÇÅ œÑrel-aux‚ÇÇ) ] /
              < R.%0 ‚àò RœÑpb.œÄ/‚ÇÅ , R.%1 ‚àò RœÑpb.œÄ/‚ÇÇ > ‚àò CR√óCR.rel‚ÇÇ      ~[ ‚àòe r (medœÑ‚ÇÄ‚ÇÅ À¢) ] /
              (R.%01 ‚àò R.œÑ ‚àò  medœÑ) ‚àò CR√óCR.rel‚ÇÇ                      ~[ ‚àòe r (‚àòe r (imgR.tr À¢) ‚äô assÀ¢) ‚äô assÀ¢ ]‚àé
              imgR.M ‚àò (imgR.C ‚àò R.œÑ ‚àò medœÑ) ‚àò CR√óCR.rel‚ÇÇ ‚àé)

            œÑrel : || Hom rœÑpb.ul imgR.Ob ||
            œÑrel = CR√óCR.univ (imgR.C ‚àò R.œÑ ‚àò medœÑ) œÑrel-pf
            œÑrel-ax‚ÇÄ = CR√óCR.epi-pf (~proof
              (r‚ÇÅ ‚àò œÑrel) ‚àò CR√óCR          ~[ assÀ¢ ‚äô ‚àòe (CR√óCR.univ-eq œÑrel-pf) r ‚äô ass ‚äô ‚àòe r tr‚ÇÅ ] /
              R.%0 ‚àò R.œÑ ‚àò medœÑ          ~[ medœÑ‚ÇÄ ‚äô ‚àòe r (tr‚ÇÅ À¢) ‚äô assÀ¢ ] /
              r‚ÇÅ ‚àò imgR.C ‚àò RœÑpb.œÄ/‚ÇÅ          ~[ ‚àòe (rœÑpb.√ó/tr‚ÇÅ CR√óCR.√ó/arcan-pf À¢) r ‚äô ass ]‚àé
              (r‚ÇÅ ‚àò rœÑpb.œÄ/‚ÇÅ) ‚àò CR√óCR ‚àé)            
            œÑrel-ax‚ÇÅ = CR√óCR.epi-pf (~proof
              (r‚ÇÇ ‚àò œÑrel) ‚àò CR√óCR           ~[ assÀ¢ ‚äô ‚àòe (CR√óCR.univ-eq œÑrel-pf) r ‚äô ass ‚äô ‚àòe r tr‚ÇÇ ] /
              R.%1 ‚àò R.œÑ ‚àò medœÑ           ~[ medœÑ‚ÇÅ ‚äô ‚àòe r (tr‚ÇÇ À¢) ‚äô assÀ¢ ] /
              r‚ÇÇ ‚àò imgR.C ‚àò RœÑpb.œÄ/‚ÇÇ           ~[ ‚àòe (rœÑpb.√ó/tr‚ÇÇ CR√óCR.√ó/arcan-pf À¢) r ‚äô ass ]‚àé
              (r‚ÇÇ ‚àò rœÑpb.œÄ/‚ÇÇ) ‚àò CR√óCR ‚àé)

    eqr/ : eqrel-over R.Lo
    eqr/ = record
      { relOb = imgR.Ob
      ; r‚ÇÅ = r‚ÇÅ
      ; r‚ÇÇ = r‚ÇÇ
      ; iseqrel = iseqr
      }

    QR = Q.Ob eqr/
    qR : || Hom R.Lo QR ||
    qR = Q.ar eqr/
    
    qR-iscoeq-rel : is-coeq r‚ÇÅ r‚ÇÇ qR
    qR-iscoeq-rel = iscoeq
                  where open is-exact-seq (ex-seq eqr/)
    private
      module qR = is-coeq qR-iscoeq-rel


    qR-iscoeq-psrel : is-coeq R.%0 R.%1 qR
    qR-iscoeq-psrel = record
      { eq = qR-coeq-psrel
      ; univ = Œª f pf ‚Üí qR.univ f (qR-univ-aux pf)
      ; univ-eq = Œª pf ‚Üí qR.univ-eq (qR-univ-aux pf)
      ; uniq = qR.uniq
      }
      where qR-coeq-psrel = ~proof qR ‚àò R.%0            ~[ ‚àòe (tr‚ÇÅ À¢) r  ] /
                                   qR ‚àò r‚ÇÅ ‚àò imgR.C     ~[ ass ‚äô ‚àòe r qR.eq ‚äô assÀ¢ ] /
                                   qR ‚àò r‚ÇÇ ‚àò imgR.C     ~[ ‚àòe tr‚ÇÇ r ]‚àé
                                   qR ‚àò R.%1 ‚àé
            qR-univ-aux : {B : Obj} {f : || Hom R.Lo B ||}
                             ‚Üí f ‚àò R.%0 ~ f ‚àò R.%1 ‚Üí f ‚àò r‚ÇÅ ~ f ‚àò r‚ÇÇ
            qR-univ-aux {f = f} pf = CR.epi-pf (~proof
              (f ‚àò r‚ÇÅ) ‚àò imgR.C          ~[ assÀ¢ ‚äô ‚àòe tr‚ÇÅ r ] /
              f ‚àò R.%0                   ~[ pf ] /
              f ‚àò R.%1                   ~[ ‚àòe (tr‚ÇÇ À¢) r ‚äô ass ]‚àé
              (f ‚àò r‚ÇÇ) ‚àò imgR.C ‚àé)

    rel-is-eff : is-pb-square (mksq (mksq/ qR.eq))
    rel-is-eff = iskerpair
               where open is-exact-seq (ex-seq eqr/)
    
  -- end exact-has-quot-peq-rel


  -------------------------------------------------------------------
  -- Exact categories have quotients of pseudo equivlaence relations
  -------------------------------------------------------------------

  quot-peq-ob : Peq ‚Üí Obj
  quot-peq-ob R = QR
                where open exact-has-quot-peq-rel R

  quot-peq-ar : (R : Peq) ‚Üí || Hom (Peq.Lo R) (quot-peq-ob R) ||
  quot-peq-ar R = qR
                where open exact-has-quot-peq-rel R

  quot-peq-coeq : (R : Peq) ‚Üí is-coeq (Peq.%0 R) (Peq.%1 R) (quot-peq-ar R)
  quot-peq-coeq R = qR-iscoeq-psrel
                  where open exact-has-quot-peq-rel R


  -- Morphisms of peq's induce arrows btw their quotients
  
  module peq-mor-to-quot-arr --(prdE : has-bin-products ùîº)
                             {peqR peqS : Peq} (ff : Peq-mor peqR peqS)
                             where
    open has-bin-products exùîº.hasprd using (prd-of)
    open Peq&prods exùîº.hasprd
    private
      module R = Peq-aux peqR
      module S = Peq-aux peqS
      module ff = Peq-mor-aux ff

    QR QS : Obj
    QR = quot-peq-ob peqR
    QS = quot-peq-ob peqS
    qR : || Hom R.Lo QR ||
    qR = quot-peq-ar peqR
    qS : || Hom S.Lo QS ||
    qS = quot-peq-ar peqS
    private
      module qR = is-coeq (quot-peq-coeq peqR)
      module qS = is-coeq (quot-peq-coeq peqS)

    qf : || Hom QR QS ||
    qf = qR.univ (qS ‚àò ff.lo) qf-pf
       where open ecategory-aux-only ùîº
             qf-pf = ~proof (qS ‚àò ff.lo) ‚àò R.%0         ~[ assÀ¢ ‚äô ‚àòe (ff.cmptb‚ÇÄ À¢) r ] /
                            qS ‚àò S.%0 ‚àò ff.hi           ~[ ass ‚äô ‚àòe r qS.eq ‚äô assÀ¢ ] /
                            qS ‚àò S.%1 ‚àò ff.hi           ~[ ‚àòe ff.cmptb‚ÇÅ r ‚äô ass ]‚àé
                            (qS ‚àò ff.lo) ‚àò R.%1 ‚àé

  -- end peq-mor-to-quot-arr


  quot-peq-morph : {R S : Peq} (ff : Peq-mor R S)
                      ‚Üí || Hom (quot-peq-ob R) (quot-peq-ob S) ||
  quot-peq-morph ff = qf
                    where open peq-mor-to-quot-arr ff

-- end exact-cat-props-only


module exact-cat-props {ùîº : ecategory} (ex : is-exact ùîº) where
  open exact-cat-props-only ex public
  open regular-cat-props exact-is-regular public
-- end exact-cat-prop


module exact-cat-d&p {ùîº : ecategory} (ex : is-exact ùîº) where
  open is-exact ex public
  open exact-cat-props ex public
--end exact-cat-d&p


--------------------------------
-- Exact categories are regular
--------------------------------

exact2reg : {ùîº : ecategory} ‚Üí is-exact ùîº ‚Üí is-regular ùîº
exact2reg excat = exact-is-regular
                where open exact-cat-props excat

