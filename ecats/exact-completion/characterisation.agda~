
-- disable the K axiom:

{-# OPTIONS --without-K  #-}

-- Agda version 2.5.4.1

module ecats.exact-completion.characterisation where

open import ecats.basic-defs.ecat-def&not
open import ecats.basic-defs.all-arrows
open import ecats.basic-props.epi&mono
open import ecats.basic-defs.regular-ecat
open import ecats.basic-defs.exact-ecat
open import ecats.basic-props.exact-ecat
open import ecats.finite-limits.defs.collective
open import ecats.functors.defs.efunctor-d&n
open import ecats.functors.defs.natural-transformation
open import ecats.functors.defs.basic-defs
open import ecats.functors.defs.preserving-functor
open import ecats.functors.defs.left-covering
open import ecats.functors.props.basic-props
open import ecats.functors.props.left-covering
open import ecats.constructions.ecat-eqrel
open import ecats.exact-completion.construction
open import ecats.exact-completion.finite-limits.fin-limits
open import ecats.exact-completion.exact.is-regular
open import ecats.exact-completion.embedding.universal-property.def
open import ecats.exact-completion.embedding.universal-property.is-left-covering



module exact-compl-universal-is-exact {â„‚ : ecategory} (hasfwl : has-fin-weak-limits â„‚) where
  private
    module â„‚ where
      open ecategory â„‚ public
      open pseudo-eq-rel-defs â„‚ public
    module Exâ„‚ where
      open ecategory Ex â„‚ [ hasfwl ] public
      open iso-defs Ex â„‚ [ hasfwl ] public
      open epis&monos-defs Ex â„‚ [ hasfwl ] public
      open epis&monos-props Ex â„‚ [ hasfwl ] public
      open image-fact-defs Ex â„‚ [ hasfwl ] public
    module Î“ex = efunctor-aux Î“ex â„‚ [ hasfwl ]
  open exact-compl-universal-def hasfwl

  module extension-is-exact {ğ”¼ : ecategory} (exğ”¼ : is-exact ğ”¼)
                            {F : efunctor â„‚ ğ”¼} (lcovF : is-left-covering F)
                            where
    private
      module ğ”¼ where
        open ecategory ğ”¼ public
        open iso-defs ğ”¼ public
        open epis&monos-defs ğ”¼ public
        open epis&monos-props ğ”¼ public
        open eq-rel-defs ğ”¼ public
        open kernel-pairs-defs ğ”¼ public
      module exğ”¼ where
        open exact-cat-d&p exğ”¼ public
      module F = efunctor-aux F
      module lcF = is-left-covering lcovF
      Fâ†‘ex : efunctor Ex â„‚ [ hasfwl ] ğ”¼
      Fâ†‘ex = â†‘ex exğ”¼ lcovF
      module Fâ†‘ex = efunctor-aux Fâ†‘ex
      regğ”¼ : is-regular ğ”¼
      regğ”¼ = exğ”¼.exact-is-regular
      -- declaring regğ”¼ explicitly is crucial for typechecking Q/Fâ†‘ex.Ob A = Fâ†‘ex.â‚’ A
      FRel : efunctor Ex â„‚ [ hasfwl ] (EqRel ğ”¼)
      FRel = Rel regğ”¼ lcovF
      module FRel where
        open efunctor-aux FRel public
        private
          module tmpOb (A : Exâ„‚.Obj) = ğ”¼.eqrel (â‚’ A)
          module tmpAr {A B : Exâ„‚.Obj} (f : || Exâ„‚.Hom A B ||) = ğ”¼.eqrel-mor (â‚ f)
        open tmpOb public
        open tmpAr public
      Q/Fâ†‘ex : (A : Exâ„‚.Obj) â†’ ğ”¼.coeq-of (FRel.râ‚ A) (FRel.râ‚‚ A)
      Q/Fâ†‘ex A = exğ”¼.eqr-has-coeq (FRel.eqrelover A)
      module Q/Fâ†‘ex (A : Exâ„‚.Obj) = ğ”¼.coeq-of (Q/Fâ†‘ex A)
