
-- disable the K axiom:

{-# OPTIONS --without-K  #-}

--show-implicit
-- Agda version 2.5.4.1

module ecats.exact-completion.embedding.universal-property.exact-fun where

open import ecats.basic-defs.ecat-def&not
open import ecats.basic-defs.all-arrows
open import ecats.basic-props.epi&mono
open import ecats.basic-defs.regular-ecat
open import ecats.basic-defs.exact-ecat
open import ecats.basic-props.exact-ecat
open import ecats.finite-limits.defs.collective
open import ecats.functors.defs.efunctor-d&n
open import ecats.functors.defs.natural-transformation
open import ecats.functors.defs.basic-defs
open import ecats.functors.defs.preserving-functor
open import ecats.functors.defs.left-covering
open import ecats.functors.props.basic-props
open import ecats.exact-completion.construction
open import ecats.exact-completion.exact.canonical-epi&mono
open import ecats.exact-completion.exact.is-regular
open import ecats.exact-completion.embedding.universal-property.eqrel-from-peq
open import ecats.constructions.ecat-eqrel
open import ecats.exact-completion.embedding.universal-property.def
open import ecats.exact-completion.embedding.universal-property.commut



module exact-compl-universal-is-exact {â„‚ : ecategory} (hasfwl : has-fin-weak-limits â„‚) where
  private
    module â„‚ where
      open ecategory â„‚ public
      open pseudo-eq-rel-defs â„‚ public
    module Exâ„‚ where
      open ecategory Ex â„‚ [ hasfwl ] public
      open iso-defs Ex â„‚ [ hasfwl ] public
      open epis&monos-defs Ex â„‚ [ hasfwl ] public
      open epis&monos-props Ex â„‚ [ hasfwl ] public
      open image-fact-defs Ex â„‚ [ hasfwl ] public
    module Î“ex = efunctor-aux Î“ex â„‚ [ hasfwl ]
  --open can-epi&mono-defs hasfwl
  open exact-compl-universal-def hasfwl
  --open eqrel-from-peq-funct hasfwl

  module extension-is-exact {ğ”¼ : ecategory} (exğ”¼ : is-exact ğ”¼)
                            {F : efunctor â„‚ ğ”¼} (lcovF : is-left-covering F)
                            where
    private
      module ğ”¼ where
        open ecategory ğ”¼ public
        open iso-defs ğ”¼ public
        open epis&monos-defs ğ”¼ public
        open epis&monos-props ğ”¼ public
        open eq-rel-defs ğ”¼ public
        open kernel-pairs-defs ğ”¼ public
      module exğ”¼ where
        open exact-cat-d&p exğ”¼ public
      module F = efunctor-aux F
      module lcF = is-left-covering lcovF
      Fâ†‘ex : efunctor Ex â„‚ [ hasfwl ] ğ”¼
      Fâ†‘ex = â†‘ex exğ”¼ lcovF
      module Fâ†‘ex = efunctor-aux Fâ†‘ex
      {-module ERğ”¼ = ecategory (EqRel ğ”¼)
      regğ”¼ : is-regular ğ”¼
      regğ”¼ = exğ”¼.exact-is-regular
      I : efunctor Ex â„‚ [ hasfwl ] (EqRel ğ”¼)
      I = imgPeq regğ”¼ lcovF
      freesq : natural-iso (I â—‹ Î“ex â„‚ [ hasfwl ]) (Î”ER ğ”¼ â—‹ F)
      freesq = imgPeq-sq regğ”¼ lcovF
      module I where
        open efunctor-aux I public
        private
          module tmpOb (A : Exâ„‚.Obj) = ğ”¼.eqrel (â‚’ A)
          module tmpAr {A B : Exâ„‚.Obj} (f : || Exâ„‚.Hom A B ||) = ğ”¼.eqrel-mor (â‚ f)
        open tmpOb public
        open tmpAr public
      module Q = efunctor-aux (QER exğ”¼)
      module cxs = canonical-ex-seq
      module CRF% (A : Exâ„‚.Obj) where
        open eqrel-from-peq-via-left-covering exğ”¼.exact-is-regular lcovF
        open eqrel-as-repi-mono-fact A public
        open rmfF% public
        open CF% public
      Fâ†‘ex-coeq : (A : Exâ„‚.Obj) â†’ ğ”¼.coeq-of (I.râ‚ A) (I.râ‚‚ A)
      Fâ†‘ex-coeq A = exğ”¼.eqr-has-coeq (I.eqrelover A)
      module Fâ†‘ex-coeq (A : Exâ„‚.Obj) = ğ”¼.coeq-of (Fâ†‘ex-coeq A)-}



    -- Preserves regular epis
    
    module preserves-repis {A B : Exâ„‚.Obj} {f : || Exâ„‚.Hom A B ||} (frepi : Exâ„‚.is-regular-epi f) where
      open ecategory-aux-only ğ”¼
      private
        module imgf where
          --open exact-compl-has-repi-mono-fact hasfwl
          open has-repi-mono-fact (ex-cmpl-rm-fact hasfwl)
          open Exâ„‚.repi-mono-fact-of (rmf-of f) public
      --open exact-compl-has-image-fact qcart
      --open img-fact-objarr f

      Fâ†‘Ob : ğ”¼.Obj
      Fâ†‘Ob = Fâ†‘ex.â‚’ imgf.Ob
      Fâ†‘C : || ğ”¼.Hom (Fâ†‘ex.â‚’ A) Fâ†‘Ob ||
      Fâ†‘M : || ğ”¼.Hom Fâ†‘Ob (Fâ†‘ex.â‚’ B) ||
      Fâ†‘C = Fâ†‘ex.â‚ imgf.C
      Fâ†‘M = Fâ†‘ex.â‚ imgf.M

      Fâ†‘tr : Fâ†‘M ğ”¼.âˆ˜ Fâ†‘C ğ”¼.~ Fâ†‘ex.â‚ f
      Fâ†‘tr = Fâ†‘ex.âˆ˜ax {f = imgf.C} {imgf.M} {f} imgf.tr

      M-iso : Exâ„‚.is-iso imgf.M
      M-iso = cov-pf imgf.tr imgf.M-is-monic
            where open Exâ„‚.is-cover (Exâ„‚.repi-is-cover frepi)

      Fâ†‘M-iso : ğ”¼.is-iso Fâ†‘M
      Fâ†‘M-iso = {!Fâ†‘ex.Fpres-iso!}
      {-record
        { invf = Fâ†‘ex.â‚ invf
        ; isiso = ? --Fiso {f = imgMono} {invf = invf} isiso
        }-}
        where open efunctor-props Fâ†‘ex using (Fpres-iso)
              open Exâ„‚.is-iso M-iso


{-
      -- Î“Fâ‚ imgREpi is repi: here we use that, in the chosen image factorisation,
      -- the quotient is represented by an identity in â„‚.
      Î“FimgQ-triang : Esh.comm-triang
      Î“FimgQ-triang = Esh.mktriang (~proof Î“Fâ‚ imgREpi âˆ˜E (Î“Fdâ‚’.Î“Fq A)               ~[ Î“Fdâ‚.sqâ‚ imgREpi ] /
                                           Î“Fdâ‚’.Î“Fq imgPeq âˆ˜E (Fâ‚ (idarC imgLo))     ~[ ridgg r Fid ]âˆ
                                           Î“Fdâ‚’.Î“Fq imgPeq âˆ)
      
      Î“FimgQ-is-cover : E-e%m.is-cover  (Î“Fâ‚ imgREpi)
      Î“FimgQ-is-cover = E-e%m.cover-triang Î“FimgQ-triang (E-e%m.repi-is-cover (Î“Fdâ‚’.Î“Fq-is-repi imgPeq))
      
      Î“FimgQ-is-regular-epi : E-e%m.is-regular-epi (Î“Fâ‚ imgREpi)
      Î“FimgQ-is-regular-epi = cover-is-regular {f = Î“Fâ‚ imgREpi} Î“FimgQ-is-cover

      -- Î“Fâ‚ imgMono is iso, since imgMono is. In particular, it's repi.
      Î“FimgTr : Î“Fâ‚ imgMono âˆ˜E Î“Fâ‚ imgREpi ~E Î“Fâ‚ f
      Î“FimgTr = Fâˆ˜g {f = imgREpi} {imgMono} {f} imgComm
              where open efunctor-aux Î“F

      imgM-is-iso : ExC-iso.is-iso imgMono
      imgM-is-iso = cov-pf imgComm imgMono-is-monic
                  where open ExC-e%m.is-cover (ExC-e%m.repi-is-cover repi)

      Î“FimgM-is-iso : E-iso.is-iso (Î“Fâ‚ imgMono)
      Î“FimgM-is-iso = record
        { invf = Î“Fâ‚ invf
        ; isiso = Fiso {f = imgMono} {invf = invf} isiso
        }
        where open efunctor-aux Î“F
              open ExC-iso.is-iso imgM-is-iso

      Î“FimgM-is-repi : E-e%m.is-regular-epi (Î“Fâ‚ imgMono)
      Î“FimgM-is-repi = E-e%m.split-epi-is-repi (E-e%m.iso-is-split-epi Î“FimgM-is-iso)
      -}

      -- Î“Fâ‚ f is repi
      Fâ†‘exf-repi : ğ”¼.is-regular-epi (Fâ†‘ex.â‚ f)
      Fâ†‘exf-repi = {!!}
      --repi-cmp Î“FimgTr Î“FimgQ-is-regular-epi Î“FimgM-is-repi

    -- end Î“F:repi2repi

  -- end extension-is-exact
-- end exact-compl-universal-is-exact
