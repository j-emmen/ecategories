
-- disable the K axiom:

{-# OPTIONS --without-K --show-implicit #-}

-- Agda version 2.5.4.1

module ecats.exact-completion.embedding.universal-property.exact where

open import ecats.basic-defs.ecat-def&not
open import ecats.basic-defs.all-arrows
open import ecats.basic-props.epi&mono
open import ecats.basic-defs.regular-ecat
open import ecats.basic-defs.exact-ecat
open import ecats.basic-props.exact-ecat
open import ecats.finite-limits.defs.collective
open import ecats.functors.defs.efunctor-d&n
open import ecats.functors.defs.natural-transformation
open import ecats.functors.defs.basic-defs
open import ecats.functors.defs.preserving-functor
open import ecats.functors.defs.left-covering
open import ecats.exact-completion.construction
open import ecats.exact-completion.exact.canonical-epi&mono
open import ecats.exact-completion.exact.is-regular
open import ecats.exact-completion.embedding.universal-property.eqrel-from-peq
open import ecats.constructions.ecat-eqrel
open import ecats.exact-completion.embedding.universal-property.def
open import ecats.exact-completion.embedding.universal-property.commut



module exact-compl-universal-is-exact {â„‚ : ecategory} (hasfwl : has-fin-weak-limits â„‚) where
  private
    module â„‚ where
      open ecategory â„‚ public
      open pseudo-eq-rel-defs â„‚ public
    module Exâ„‚ where
      open ecategory Ex â„‚ [ hasfwl ] public
      open epis&monos-defs Ex â„‚ [ hasfwl ] public
      open epis&monos-props Ex â„‚ [ hasfwl ] public
      open image-fact-defs Ex â„‚ [ hasfwl ] public
    module Î“ex = efunctor-aux Î“ex â„‚ [ hasfwl ]
  --open can-epi&mono-defs hasfwl
  open exact-compl-universal-def hasfwl
  --open eqrel-from-peq-funct hasfwl

  module extension-is-exact {ğ”¼ : ecategory} (exğ”¼ : is-exact ğ”¼)
                            {F : efunctor â„‚ ğ”¼} (lcovF : is-left-covering F)
                            where
    private
      module ğ”¼ where
        open ecategory ğ”¼ public
        open iso-defs ğ”¼ public
        open epis&monos-defs ğ”¼ public
        open epis&monos-props ğ”¼ public
        open eq-rel-defs ğ”¼ public
        open kernel-pairs-defs ğ”¼ public
      module exğ”¼ where
        open exact-cat-d&p exğ”¼ public
      module F = efunctor-aux F
      module lcF = is-left-covering lcovF
      Fâ†‘ex : efunctor Ex â„‚ [ hasfwl ] ğ”¼
      Fâ†‘ex = â†‘ex exğ”¼ lcovF
      module Fâ†‘ex = efunctor-aux Fâ†‘ex
      {-module ERğ”¼ = ecategory (EqRel ğ”¼)
      regğ”¼ : is-regular ğ”¼
      regğ”¼ = exğ”¼.exact-is-regular
      I : efunctor Ex â„‚ [ hasfwl ] (EqRel ğ”¼)
      I = imgPeq regğ”¼ lcovF
      freesq : natural-iso (I â—‹ Î“ex â„‚ [ hasfwl ]) (Î”ER ğ”¼ â—‹ F)
      freesq = imgPeq-sq regğ”¼ lcovF
      module I where
        open efunctor-aux I public
        private
          module tmpOb (A : Exâ„‚.Obj) = ğ”¼.eqrel (â‚’ A)
          module tmpAr {A B : Exâ„‚.Obj} (f : || Exâ„‚.Hom A B ||) = ğ”¼.eqrel-mor (â‚ f)
        open tmpOb public
        open tmpAr public
      module Q = efunctor-aux (QER exğ”¼)
      module cxs = canonical-ex-seq
      module CRF% (A : Exâ„‚.Obj) where
        open eqrel-from-peq-via-left-covering exğ”¼.exact-is-regular lcovF
        open eqrel-as-repi-mono-fact A public
        open rmfF% public
        open CF% public
      Fâ†‘ex-coeq : (A : Exâ„‚.Obj) â†’ ğ”¼.coeq-of (I.râ‚ A) (I.râ‚‚ A)
      Fâ†‘ex-coeq A = exğ”¼.eqr-has-coeq (I.eqrelover A)
      module Fâ†‘ex-coeq (A : Exâ„‚.Obj) = ğ”¼.coeq-of (Fâ†‘ex-coeq A)-}



    -- Preserves regular epis
    
    module preserves-repis {A B : Exâ„‚.Obj} {f : || Exâ„‚.Hom A B ||} (repi : Exâ„‚.is-regular-epi f) where
      open ecategory-aux-only ğ”¼
      private
        module imgf where
          --open exact-compl-has-repi-mono-fact hasfwl
          open has-repi-mono-fact (ex-cmpl-rm-fact hasfwl)
          open Exâ„‚.repi-mono-fact-of (rmf-of f) public
      --open exact-compl-has-image-fact qcart
      --open img-fact-objarr f

      check : {X Y Z : Exâ„‚.Obj} {g' : || Exâ„‚.Hom X Y ||} {g : || Exâ„‚.Hom Y Z ||} {h : || Exâ„‚.Hom X Z ||}
                 â†’ g Exâ„‚.âˆ˜ g' Exâ„‚.~ h â†’ Fâ†‘ex.â‚ g ğ”¼.âˆ˜ Fâ†‘ex.â‚ g' ğ”¼.~ Fâ†‘ex.â‚ h
      check {X} {Y} {Z} {g'} {g} {h} pf = {!imgf.M!} --Fâ†‘ex.âˆ˜ax {f = g'} {g} {h} pf --Fâ†‘ex.âˆ˜ax {f = g'} {g} {h} pf --Fâ†‘ex.âˆ˜ax {X} {Y} {Z} {g'} {g} {h} pf

      Fâ†‘tr : Fâ†‘ex.â‚ imgf.M ğ”¼.âˆ˜ Fâ†‘ex.â‚ imgf.C ğ”¼.~ Fâ†‘ex.â‚ f
      Fâ†‘tr = {!Fâ†‘ex.âˆ˜ax {A} {imgf.Ob} {B} {f = imgf.C} {imgf.M} {f} imgf.tr!} 
      
{-
ğ”¼._âˆ˜_
{Fâ†‘ex.FObj A}
{Fâ†‘ex.FObj
 (can-epi&mono-defs.canonical-mono.Ob
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f))}
{Fâ†‘ex.FObj B}
(Fâ†‘ex.â‚
 {can-epi&mono-defs.canonical-mono.Ob
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f)}
 {B}
 (can-epi&mono-defs.canonical-mono.ar
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (can-epi&mono-defs.can-mono-constr.cmar-data
     {â„‚} hasfwl {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} (â„‚.Peq&prods.Peq-mor-aux.lo f) (â„‚.Peq.peqover B))))
(Fâ†‘ex.â‚ 
 {A}
 {can-epi&mono-defs.canonical-mono.Ob
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f)}
 imgf.C)

ğ”¼._âˆ˜_
{Fâ†‘ex.FObj A}
{Fâ†‘ex.FObj
 (can-epi&mono-defs.canonical-mono.Ob
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f))}
{Fâ†‘ex.FObj B}
(Fâ†‘ex.â‚
 {can-epi&mono-defs.canonical-mono.Ob
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f)}
 {B}
 (can-epi&mono-defs.canonical-mono.ar
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f)))
(Fâ†‘ex.â‚ {A}
 {can-epi&mono-defs.canonical-mono.Ob
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.Lo B} {â„‚.Peq&prods.Peq-mor-aux.lo f} {â„‚.Peq.peqover B}
   (exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf-data {â„‚} hasfwl {A} {B} f)}
 (can-epi&mono-defs.canonical-repi.ar
   {â„‚} {hasfwl} {â„‚.Peq.Lo A} {â„‚.Peq.peqover A}
   {exact-compl-has-repi-mono-fact.rem-fact-objarr.cmf.Ob/ {â„‚} hasfwl {A} {B} f}
  (exact-compl-has-repi-mono-fact.rem-fact-objarr.crf-data {â„‚} hasfwl {A} {B} f)))
-}

{-
      -- Î“Fâ‚ imgREpi is repi: here we use that, in the chosen image factorisation,
      -- the quotient is represented by an identity in â„‚.
      Î“FimgQ-triang : Esh.comm-triang
      Î“FimgQ-triang = Esh.mktriang (~proof Î“Fâ‚ imgREpi âˆ˜E (Î“Fdâ‚’.Î“Fq A)               ~[ Î“Fdâ‚.sqâ‚ imgREpi ] /
                                           Î“Fdâ‚’.Î“Fq imgPeq âˆ˜E (Fâ‚ (idarC imgLo))     ~[ ridgg r Fid ]âˆ
                                           Î“Fdâ‚’.Î“Fq imgPeq âˆ)
      
      Î“FimgQ-is-cover : E-e%m.is-cover  (Î“Fâ‚ imgREpi)
      Î“FimgQ-is-cover = E-e%m.cover-triang Î“FimgQ-triang (E-e%m.repi-is-cover (Î“Fdâ‚’.Î“Fq-is-repi imgPeq))
      
      Î“FimgQ-is-regular-epi : E-e%m.is-regular-epi (Î“Fâ‚ imgREpi)
      Î“FimgQ-is-regular-epi = cover-is-regular {f = Î“Fâ‚ imgREpi} Î“FimgQ-is-cover

      -- Î“Fâ‚ imgMono is iso, since imgMono is. In particular, it's repi.
      Î“FimgTr : Î“Fâ‚ imgMono âˆ˜E Î“Fâ‚ imgREpi ~E Î“Fâ‚ f
      Î“FimgTr = Fâˆ˜g {f = imgREpi} {imgMono} {f} imgComm
              where open efunctor-aux Î“F

      imgM-is-iso : ExC-iso.is-iso imgMono
      imgM-is-iso = cov-pf imgComm imgMono-is-monic
                  where open ExC-e%m.is-cover (ExC-e%m.repi-is-cover repi)

      Î“FimgM-is-iso : E-iso.is-iso (Î“Fâ‚ imgMono)
      Î“FimgM-is-iso = record
        { invf = Î“Fâ‚ invf
        ; isiso = Fiso {f = imgMono} {invf = invf} isiso
        }
        where open efunctor-aux Î“F
              open ExC-iso.is-iso imgM-is-iso

      Î“FimgM-is-repi : E-e%m.is-regular-epi (Î“Fâ‚ imgMono)
      Î“FimgM-is-repi = E-e%m.split-epi-is-repi (E-e%m.iso-is-split-epi Î“FimgM-is-iso)
      -}

      -- Î“Fâ‚ f is repi
      Fâ†‘exf-repi : ğ”¼.is-regular-epi (Fâ†‘ex.â‚ f)
      Fâ†‘exf-repi = exğ”¼.repi-cmp {!!} {!!} {!!}
      --repi-cmp Î“FimgTr Î“FimgQ-is-regular-epi Î“FimgM-is-repi

    -- end Î“F:repi2repi

  -- end extension-is-exact
-- end exact-compl-universal-is-exact
